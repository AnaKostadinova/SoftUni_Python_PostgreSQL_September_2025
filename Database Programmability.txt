Lab Exercises

Count Employees by Town

CREATE OR REPLACE FUNCTION fn_count_employees_by_town(town_name VARCHAR(20)) 
RETURNS INT AS
$$
    DECLARE
        employees_count INT;
    BEGIN
        SELECT
            COUNT(e.employee_id)
        FROM
            employees AS e
        JOIN
            addresses AS a
        USING
            (address_id)
        JOIN
            towns AS t
        USING
            (town_id)
        WHERE
            t.name = town_name INTO employees_count;
        RETURN
            employees_count;
    END
$$
LANGUAGE plpgsql
;

SELECT
    fn_count_employees_by_town('Sofia')

Employees Promotion

CREATE OR REPLACE PROCEDURE sp_increase_salaries(department_name VARCHAR)
AS
$$
    BEGIN
        UPDATE
            employees
        SET
            salary = salary * 1.05
        WHERE
            department_id = 
                (SELECT department_id FROM departments WHERE name = department_name);
    END
$$
LANGUAGE plpgsql
;

Employees Promotion By ID

CREATE OR REPLACE PROCEDURE sp_increase_salary_by_id(id INT)
AS
$$
    BEGIN
        IF
            (SELECT employee_id FROM employees WHERE employee_id = id) IS NULL
        THEN RETURN;
        END IF;
        UPDATE employees
        SET
            salary = salary * 1.05 WHERE employee_id = id;
        COMMIT;
    END;
$$
LANGUAGE plpgsql
;

Triggered

CREATE TABLE deleted_employees(
    employee_id SERIAL PRIMARY KEY,
    first_name VARCHAR(20),
    last_name VARCHAR(20),
    middle_name VARCHAR(20),
    job_title VARCHAR(50),
    department_id INT,
    salary NUMERIC(19, 4)
)
;

CREATE OR REPLACE FUNCTION fired_employees()
RETURNS TRIGGER AS
$$
    BEGIN
        INSERT INTO deleted_employees(first_name, last_name, middle_name, job_title, department_id, salary)
        VALUES (
            old.first_name, 
            old.last_name, 
            old.middle_name, 
            old.job_title, 
            old.department_id, 
            old.salary
        );
        RETURN old;
            
    END
$$
LANGUAGE plpgsql;

CREATE TRIGGER fired_employees_trigger
AFTER DELETE ON employees
FOR EACH ROW EXECUTE PROCEDURE fired_employees();


Homework Exercises

User-defined Function Full Name

CREATE OR REPLACE FUNCTION fn_full_name(first_name VARCHAR(50), last_name VARCHAR(50))
RETURNS VARCHAR AS
$$
	DECLARE
		full_name VARCHAR(50);
	BEGIN
		IF first_name IS NULL AND last_name IS NULL THEN
			full_name = NULL;
		ELSE
			SELECT
				CONCAT(INITCAP(first_name), ' ', INITCAP(last_name)) INTO full_name;
		END IF;
		RETURN full_name;
	END
$$
LANGUAGE plpgsql;

User-defined Function Future Value

CREATE OR REPLACE FUNCTION fn_calculate_future_value(initial_sum DECIMAL, yearly_interest_rate DECIMAL, number_of_years INT)
RETURNS DECIMAL AS
$$
    DECLARE
        future_investment_value DECIMAL;
    BEGIN
        SELECT initial_sum * (1 + yearly_interest_rate) ^ number_of_years INTO future_investment_value;
        RETURN
            TRUNC(future_investment_value, 4);
    END
$$  
LANGUAGE plpgsql;

SELECT fn_calculate_future_value(2500, 0.30, 2);


User-defined Function Is Word Comprised

CREATE OR REPLACE FUNCTION fn_is_word_comprised(set_of_letters VARCHAR(50), word VARCHAR(50))
RETURNS BOOLEAN AS
$$	
	DECLARE
		i INT;
		letter CHAR(1);
	BEGIN
		FOR i IN 1..LENGTH(word) LOOP
			letter := SUBSTRING(LOWER(word), i, 1);
		IF POSITION(letter IN LOWER(set_of_letters)) = 0 THEN
			RETURN FALSE;
			END IF;
		END LOOP;
		RETURN TRUE;
	END
$$
LANGUAGE plpgsql;

Game Over

CREATE OR REPLACE FUNCTION fn_is_game_over(is_game_over BOOLEAN)
RETURNS TABLE (
name VARCHAR(50),
game_type_id INT, 
is_finished BOOLEAN)
AS
$$
	BEGIN
		RETURN QUERY 
			SELECT
				g.name,
				g.game_type_id, 
				g.is_finished
			FROM
				games AS g
			WHERE
				g.is_finished = is_game_over;
	END
$$
LANGUAGE plpgsql;

Difficulty Level

CREATE OR REPLACE FUNCTION fn_difficulty_level(level INT)
RETURNS VARCHAR
AS
$$
	DECLARE
		difficulty_level VARCHAR;
	BEGIN
		IF level <= 40 THEN difficulty_level := 'Normal Difficulty';
		ELSIF level BETWEEN 41 AND 60 THEN difficulty_level := 'Nightmare Difficulty';
		ELSE difficulty_level := 'Hell Difficulty';
		END IF;
		
		RETURN difficulty_level;
	END
$$
LANGUAGE plpgsql;

Cash in User Games Odd Rows

CREATE OR REPLACE FUNCTION fn_cash_in_users_games(game_name VARCHAR(50))
RETURNS TABLE(
	total_cash NUMERIC
)
AS
$$
	BEGIN
		RETURN QUERY 
		WITH
			ranked_games
		AS (			
			SELECT
				cash,
				ROW_NUMBER() OVER (ORDER BY cash DESC) AS "row_num"
			FROM
				users_games AS ug
			JOIN
				games AS g
			ON
				ug.game_id = g.id
			WHERE
				g.name = game_name
		)

		SELECT
			ROUND(SUM(cash), 2)
		FROM
			ranked_games
		WHERE
			row_num % 2 <>0;
	END
$$
LANGUAGE plpgsql;

Deposit Money

CREATE OR REPLACE PROCEDURE sp_deposit_money(
account_id INT, money_amount NUMERIC(10,4))
AS
$$
    BEGIN
        UPDATE
            accounts
        SET
            balance = balance + money_amount
        WHERE
            id = account_id;
    END
$$
LANGUAGE plpgsql;

 Withdraw Money

CREATE OR REPLACE PROCEDURE sp_withdraw_money(
account_id INT,
money_amount NUMERIC(10, 4)
)
AS
$$
	BEGIN
		IF (SELECT balance FROM accounts WHERE id = account_id) >= money_amount THEN 
			UPDATE
				accounts
			SET balance = balance - money_amount
			WHERE
				id = account_id;
		ELSE
			RAISE NOTICE 'Insufficient balance to withdraw %', money_amount;
		END IF;
	END
$$
LANGUAGE plpgsql;

Money Transfer

CREATE OR REPLACE PROCEDURE sp_transfer_money(
sender_id INT,
receiver_id INT,
amount NUMERIC(10,4)
)
AS
$$
	BEGIN
		CALL sp_withdraw_money(sender_id, amount);
		IF (SELECT balance FROM accounts WHERE sender_id = id) >= amount THEN
			CALL sp_deposit_money(receiver_id, amount);
		END IF;
	END
$$
LANGUAGE plpgsql;

Log Accounts Trigger

CREATE TABLE logs(
	id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY, 
	account_id INT, 
	old_sum NUMERIC, 
	new_sum NUMERIC
);

CREATE OR REPLACE FUNCTION trigger_fn_insert_new_entry_into_logs()
RETURNS TRIGGER
AS
$$
	BEGIN
		INSERT INTO logs(account_id, old_sum, new_sum)
		VALUES 
			(OLD.id, OLD.balance, new.balance);
		RETURN NEW;
	END
$$
LANGUAGE plpgsql;

CREATE TRIGGER tr_account_balance_change
AFTER UPDATE OF balance ON accounts
FOR EACH ROW
WHEN
	(OLD.balance <> NEW.BALANCE)
EXECUTE FUNCTION trigger_fn_insert_new_entry_into_logs();


Notification Email on Balance Change

CREATE TABLE notification_emails(
	id INT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
	recipient_id INT,
	subject VARCHAR,
	body TEXT
);

CREATE OR REPLACE FUNCTION 
	trigger_fn_send_email_on_balance_change()
RETURNS TRIGGER AS
$$
	BEGIN
		INSERT INTO notification_emails(recipient_id, subject, body)
	VALUES
		(
			NEW.account_id,
			'Balance change for account: %', NEW.account_id,
			'On % your balance was changed from % to %.', DATE(NOW()), NEW.old_sum, NEW.new_sum
		);
	RETURN NEW;
	END
$$
LANGUAGE plpgsql;

CREATE TRIGGER tr_send_email_on_balance_change
AFTER UPDATE ON logs
FOR EACH ROW
EXECUTE FUNCTION trigger_fn_send_email_on_balance_change();

